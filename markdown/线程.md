[返回](index.md)

- [线程介绍](#线程介绍)
  - [并发和并行](#并发和并行)
- [线程使用 #⭐️](#线程使用-️)
  - [区别](#区别)
- [线程终止](#线程终止)
- [线程方法](#线程方法)
  - [第一组](#第一组)
  - [第二组](#第二组)
- [线程生命周期](#线程生命周期)
- [Synchronized #⭐️](#synchronized-️)
- [互斥锁 #⭐️](#互斥锁-️)
- [死锁](#死锁)

## 线程介绍
```mermaid
graph LR;
程序-->|运行|进程
```
1）线程由进程创建，是进程的一个实体

2）一个进程可以拥有多个线程

单线程：同一个时刻，只允许执一个线程

多线程：同一个时刻，可以执行多个线程，比如一个qq进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件
### 并发和并行
1）并发：同一个时刻，多个任务交替执行，造成一种”貌似同时“的错觉，简单的说，**单核cpu实现的多任务就是并发**

2）并行：同一个时刻，多个任务同时执行。**多核cpu可以实现并行**

```java
//获取cpu个数
public class exercise01 {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        int cpuCount = runtime.availableProcessors();
        System.out.println(cpuCount);
    }
}
```
## 线程使用 #⭐️ 

<img src="https://stolorzs.github.io/Picgo/drawio/Thread.SVG">

[空降]([https://](https://www.bilibili.com/video/BV1fh411y7R8?t=905.2&p=583))

创建线程的两种方式
- 继承Thread类，重写run方法
- 实现Runnable接口，重写run方法

`ps:` Thread类实现了Runnable接口，重写其run方法

```java
public class  {
  public static void main(String[] args) {
    Car car = new Car(); 
    car.start();
    Dog dog = new Dog();
    Thread thread = new Tread(dog);
    thread.start();
  }
}
class Car extends Thread
{
  @Override
  public void run(){
      //使用Thread.sleep需要try-catch
  }
}
class Dog implements Runnable{
    @Override
  public void run(){

  }
}
```

<details><summary>线程代理类</summary>

```java
//使用别的类帮我调用我没有的方法，但结果还是调用自己的方法
class ThreadProxy implements Runnable {
  private Runnable target = null;
  @Override
  public void run() {
    if (target != null){
      target.run();
    }
  }
  public ThreadProxy(Runnalbe target) {
    this.target = target;
  }
  public void start(){
    start0();
  }
  public void start0(){
    run();
  }
}
``` 
</details>


### 区别
1）两种创建线程的方式本质上没有区别

2）实现`Runnable`接口方式更加适合**多个线程共享一个资源**的情况，并且避免了单继承的限制 (建议使用)
```java
//两个线程共享一个资源
T3 t3 = new T3();
Thread thread01 = new Thread(t3);
Thread thread02 = new Thread(t3);
thread01.start();
thread02.start();
```


## 线程终止

1）当线程完成任务后会自动退出

2）还可以通过使用变量来控制run方法退出以停止线程——通知方式
```java
class T extends Thread {
    private boolean loop = true;\
    //在主线程中调用setLoop方法控制线程退出
    public void setLoop(boolean loop){
      this.loop = loop;
    }
    @Override
    public void run() {
      while(loop){
        //线程内容
      }
    }
  }
```
## 线程方法
### 第一组
[空降]([https://](https://www.bilibili.com/video/BV1fh411y7R8?t=615.1&p=589))
- `setName`
- `getName`
- `start`底层创建线程，调用run，run不会启动新的线程
- `run`
- `setPriority`更改线程优先级
- `getPriority`获取线程优先级
- `sleep`线程的静态方法
- `interrupt`中断线程，没有真正结束线程，可以提前结束线程休眠(sleep)
  - 某线程调用`interrupt`后，会在Thread.sleep()中抛出一个异常
- **线程优先级的范围**
  - MAX_PRIORITY = 10
  - MIN_PRIORITY = 1
  - NORM_PRIORITY = 5

```java
public class Test {
  public static void main(String[] args) {
   T t = new T();
   t.start();
    //t线程休眠...
   t.interrupt;//中断t线程的休眠
  }
}
class T extends Thread {
  @Override
  public void run() {
    while (true) {
      for(int i = 0; i < 100; i++) {
        //执行程序
      }
      try {
        //休眠:20秒
        Thread.sleep(20000);
      } catch (InterruptedException e){
        //调用T的interrupt方法时会捕获
        //程序接着执行
      }
    }
  }
}
```
### 第二组
[空降]([https://](https://www.bilibili.com/video/BV1fh411y7R8?t=794.3&p=590))
- `yield`：线程的礼让，让出cpu，让其他线程执行，但不一定成功
- `join`：线程的插队，一旦插队成功，则肯定先执行完**插入的线程**的**所有的任务**


<img src="https://stolorzs.github.io/Picgo/drawio/ThreadJoin.svg">

```java
public class Test {
  public static void main(String[] args) throws InterruptedException {
    T t = new T();
    t.start();
    for(int i = 1; i <= 20; i++) {
      Tread.sleep(1000);
      System.out.println("主线程吃" + i);
      if(i == 5) {
        System.out.println("主线程让子线程吃");
        t.join();
        System.out.println("子线程吃完了，主线程接着吃");
      }
    }
  }
}
class T extends Thread {
  @Override 
  public void run() {
    for(int i = 1; i <= 20; i++) {
      try {
        Tread.sleep(1000);
      } catch (InterruptedException e){      }
      System.out.println("子线程吃" + i);
    }
  }
}

```

## 线程生命周期

## Synchronized #⭐️ 

## 互斥锁 #⭐️ 

## 死锁